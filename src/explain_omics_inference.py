#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""explain_omics_inference.py

Lightweight inference over EXPLAIN-OMICS outputs.

Use-cases (partial user input):
- Microbe list only -> rank pathways, host modules, (optional) genes
- Pathway list only -> rank host modules (+ optional microbes)
- Microbe + pathway -> rank consistent chains

This does NOT re-train anything; it reads the CSV artifacts generated by the pipeline.
"""

import argparse
import os
import re
from typing import Any, Dict, List, Sequence

import pandas as pd


def _norm(x: Any) -> str:
    s = "" if x is None else str(x)
    s = s.strip().lower()
    s = re.sub(r"\s+", " ", s)
    return s


def _as_list(x: Any) -> List[str]:
    if x is None:
        return []
    if isinstance(x, (list, tuple, set)):
        return [str(i) for i in x if str(i).strip()]
    # comma-separated
    if isinstance(x, str) and "," in x:
        return [p.strip() for p in x.split(",") if p.strip()]
    return [str(x)]


class ExplainOmicsInference:
    def __init__(self, csv_dir: str):
        self.csv_dir = csv_dir

        self.triplets = pd.read_csv(os.path.join(csv_dir, "Triplets_HostModule_Pathway_Microbe.csv"))
        self.mp_links = pd.read_csv(os.path.join(csv_dir, "Microbe_to_Pathway_Links.csv"))
        self.ph_links = pd.read_csv(os.path.join(csv_dir, "Pathway_to_HostModule_Links.csv"))

        chain4_path = os.path.join(csv_dir, "Chains4_Microbe_Pathway_HostModule_Gene.csv")
        self.chain4 = pd.read_csv(chain4_path) if os.path.exists(chain4_path) else None

        pred_mp = os.path.join(csv_dir, "PredictedLinks_Microbe_Pathway.csv")
        pred_ph = os.path.join(csv_dir, "PredictedLinks_Pathway_HostModule.csv")
        self.pred_mp = pd.read_csv(pred_mp) if os.path.exists(pred_mp) else None
        self.pred_ph = pd.read_csv(pred_ph) if os.path.exists(pred_ph) else None

        # normalized columns for robust matching
        self.triplets["_m"] = self.triplets["Genus"].map(_norm)
        self.triplets["_p"] = self.triplets["Obj2_Pathway"].map(_norm)

        self.mp_links["_m"] = self.mp_links["Genus"].map(_norm)
        self.mp_links["_p"] = self.mp_links["Obj2_Pathway"].map(_norm)

        self.ph_links["_p"] = self.ph_links["Obj2_Pathway"].map(_norm)

        if self.chain4 is not None:
            self.chain4["_m"] = self.chain4["Genus"].map(_norm)
            self.chain4["_p"] = self.chain4["Obj2_Pathway"].map(_norm)

    def query(
        self,
        microbes: Sequence[str] | None = None,
        pathways: Sequence[str] | None = None,
        top_k: int = 25,
        use_predicted_links: bool = True,
    ) -> Dict[str, pd.DataFrame]:

        microbes_n = [_norm(x) for x in _as_list(microbes)]
        pathways_n = [_norm(x) for x in _as_list(pathways)]

        T = self.triplets.copy()
        if microbes_n:
            T = T[T["_m"].isin(microbes_n)]
        if pathways_n:
            T = T[T["_p"].isin(pathways_n)]

        # If exact triplets not found, fall back to 2-layer inference
        if T.empty:
            if microbes_n and not pathways_n:
                P = self.mp_links[self.mp_links["_m"].isin(microbes_n)].copy()
                if use_predicted_links and self.pred_mp is not None and not self.pred_mp.empty:
                    pred = self.pred_mp.copy()
                    pred["_m"] = pred["NodeA"].map(_norm)
                    pred["_p"] = pred["NodeB"].map(_norm)
                    pred = pred[pred["_m"].isin(microbes_n)]
                    pred = pred.rename(columns={"NodeA": "Genus", "NodeB": "Obj2_Pathway"})
                    # treat predicted edges as weaker evidence
                    scale = float(P["LinkScore"].max()) if len(P) else 1.0
                    pred["LinkScore"] = pd.to_numeric(pred["PredScore_Cosine"], errors="coerce").fillna(0.0) * scale
                    P = pd.concat([P[["Genus", "Obj2_Pathway", "LinkScore"]], pred[["Genus", "Obj2_Pathway", "LinkScore"]]], ignore_index=True)

                top_pathways = (
                    P.groupby("Obj2_Pathway", as_index=False)["LinkScore"].sum()
                    .sort_values("LinkScore", ascending=False)
                    .head(top_k)
                )

                ph = self.ph_links.copy()
                ph = ph[ph["_p"].isin(top_pathways["Obj2_Pathway"].map(_norm))]
                top_host = (
                    ph.groupby("host_module", as_index=False)["Evidence_Score_Obj2"].sum()
                    .sort_values("Evidence_Score_Obj2", ascending=False)
                    .head(top_k)
                )

                return {
                    "top_pathways": top_pathways,
                    "top_host_modules": top_host,
                    "top_chains": pd.DataFrame(),
                }

            if pathways_n and not microbes_n:
                ph = self.ph_links[self.ph_links["_p"].isin(pathways_n)].copy()
                if use_predicted_links and self.pred_ph is not None and not self.pred_ph.empty:
                    pred = self.pred_ph.copy()
                    pred["_p"] = pred["NodeA"].map(_norm)
                    pred = pred[pred["_p"].isin(pathways_n)]
                    pred = pred.rename(columns={"NodeA": "Obj2_Pathway", "NodeB": "host_module"})
                    scale = float(ph["Evidence_Score_Obj2"].max()) if len(ph) else 1.0
                    pred["Evidence_Score_Obj2"] = pd.to_numeric(pred["PredScore_Cosine"], errors="coerce").fillna(0.0) * scale
                    ph2 = pd.concat([ph[["Obj2_Pathway", "host_module", "Evidence_Score_Obj2"]], pred[["Obj2_Pathway", "host_module", "Evidence_Score_Obj2"]]], ignore_index=True)
                else:
                    ph2 = ph[["Obj2_Pathway", "host_module", "Evidence_Score_Obj2"]]

                top_host = (
                    ph2.groupby("host_module", as_index=False)["Evidence_Score_Obj2"].sum()
                    .sort_values("Evidence_Score_Obj2", ascending=False)
                    .head(top_k)
                )

                return {
                    "top_host_modules": top_host,
                    "top_chains": pd.DataFrame(),
                }

            return {"top_chains": pd.DataFrame()}

        # Normal case: triplets exist
        T = T.sort_values(["ChainScore", "TripletConfidence"], ascending=[False, False])
        top_chains = T.head(top_k).copy()

        top_microbes = (
            T.groupby("Genus", as_index=False)["ChainScore"].sum()
            .sort_values("ChainScore", ascending=False)
            .head(top_k)
        )
        top_pathways = (
            T.groupby("Obj2_Pathway", as_index=False)["ChainScore"].sum()
            .sort_values("ChainScore", ascending=False)
            .head(top_k)
        )
        top_host = (
            T.groupby("host_module", as_index=False)["ChainScore"].sum()
            .sort_values("ChainScore", ascending=False)
            .head(top_k)
        )

        out: Dict[str, pd.DataFrame] = {
            "top_chains": top_chains,
            "top_microbes": top_microbes,
            "top_pathways": top_pathways,
            "top_host_modules": top_host,
        }

        if self.chain4 is not None and "ChainGeneScore" in self.chain4.columns:
            C4 = self.chain4.copy()
            if microbes_n:
                C4 = C4[C4["_m"].isin(microbes_n)]
            if pathways_n:
                C4 = C4[C4["_p"].isin(pathways_n)]
            if not C4.empty:
                out["top_genes"] = (
                    C4.groupby("Gene", as_index=False)["ChainGeneScore"].sum()
                    .sort_values("ChainGeneScore", ascending=False)
                    .head(top_k)
                )
                out["top_4layer_chains"] = C4.sort_values("ChainGeneScore", ascending=False).head(top_k)

        return out


def main():
    ap = argparse.ArgumentParser(description="EXPLAIN-OMICS inference over pipeline outputs")
    ap.add_argument("--csv_dir", default="results/explain_omics/csv", help="Folder containing pipeline CSV outputs")
    ap.add_argument("--microbes", default=None, help="Microbes (comma-separated)")
    ap.add_argument("--pathways", default=None, help="Pathways (comma-separated)")
    ap.add_argument("--top_k", type=int, default=20)
    ap.add_argument("--no_pred", action="store_true", help="Disable predicted links usage")
    ap.add_argument("--out", default=None, help="Optional output CSV prefix (writes ranked tables)")
    args = ap.parse_args()

    inf = ExplainOmicsInference(args.csv_dir)
    res = inf.query(
        microbes=_as_list(args.microbes),
        pathways=_as_list(args.pathways),
        top_k=args.top_k,
        use_predicted_links=(not args.no_pred),
    )

    # Print summaries
    for k, df in res.items():
        print(f"\n## {k} ({len(df)})")
        if isinstance(df, pd.DataFrame) and not df.empty:
            print(df.head(min(10, len(df))).to_string(index=False))

    # Optional save
    if args.out:
        for k, df in res.items():
            if isinstance(df, pd.DataFrame) and not df.empty:
                df.to_csv(f"{args.out}.{k}.csv", index=False)


if __name__ == "__main__":
    main()
